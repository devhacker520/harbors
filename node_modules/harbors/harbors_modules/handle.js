var harbors = require('./harbors');

var fs = require("fs");
var url = require("url");
var zlib = require("zlib");
var path = require("path");

var _mime = require("./mime");

module.exports = function(req, res, num){
    return new object(req, res, num);
};

var object = function(req, res, config){
    this.request = req;
    this.response = res;
    this._config = config;
    this._path = url.parse(req.url);
    this._header = {};
    this._statusCode = 200;
    this.client = {
        get ip(){ return req.connection.remoteAddress; },
        get headers(){ return req.headers; },
        get url(){ return req.url; },
        get method(){ return req.method; }
    };
};

object.prototype.send = function(string){
    var self = this;
    //动态文件处理后需要跟随send方法一起执行的函数全部存在以下变量里
    this._resultsEnd && this._resultsEnd();
    //zip模块处理
    /**
     * TODO :
     * gzip文件流缓存，第二次直接调用缓存的数据
     * 匹配需要压缩的扩展名
     * 文件类型匹配
     */
    var type = typeof(string);
    //判断压缩模块是否开启
    if(self._config._module >> 2 & 0x1 && string != undefined){
        if(self.client.headers['accept-encoding'] && self.client.headers['accept-encoding'].indexOf('gzip')>-1){
            self._header['Content-Encoding'] = 'gzip';
            harbors.log("Zip module : Gzip");
            zlib.gzip(string, function(error, result){
                if(error) throw error;
                self._header['Content-Length'] = result.length;
                self.response.writeHeader(self._statusCode,self._header);
                self.response.end(result);
            });
            return undefined;
        }else if(self.client.headers['accept-encoding'].indexOf('deflate')>-1){
            this._header['Content-Encoding'] = 'deflate';
            harbors.log("Zip module : Deflate");
            zlib.deflateRaw(string, function(error, result){
                if(error) throw error;
                self._header['Content-Length'] = result.length;
                self.response.writeHeader(self._statusCode,self._header);
                self.response.end(result);
            });
            return undefined;
        }
    }

    //文件长度
    if(type == 'string')
        this._header['Content-Length'] = Buffer.byteLength(string, 'utf-8');
    else if(type == 'undefined')
        this._header['Content-Length'] = 0;
    else
        this._header['Content-Length'] = string.length;

    this.response.writeHeader(this._statusCode,this._header);
    this.response.end(string);
};

object.prototype.notFound = function(){
    harbors.log("Url is not found...");
    this._statusCode = 404;
    this.send('error 404');
};

object.prototype.error = function(){
    harbors.log("Server is error...");
    this._statusCode = 500;
    this.send('error 500');
};

object.prototype.display = function(file, ab){
    var self = this;
    try{
        var realFile;
        ab ?
            realFile = file :
            realFile = path.join(self._config.dir, file);
        harbors.log("Display file : ", realFile);
        this._header["Content-type"] = _mime[path.extname(file)] || "text/html";
        var stat = fs.statSync(realFile);
        //304状态响应
        var lastModified = stat.mtime.toUTCString();
        var ifModifiedSince = "If-Modified-Since".toLowerCase();
        self._statusCode = 200;
        if(lastModified == self.client.headers[ifModifiedSince]){
            self._statusCode = 304;
            self.send();
            return undefined;
        }else{
            self._header["Last-Modified"] = lastModified;
        }
        var html = fs.readFileSync(realFile);
        self.send(html);
    }catch(err){
        console.log(err);
        self.notFound();
    }
};