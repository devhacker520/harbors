var path = require('path');
var cluster = require('cluster');
var __fs__ = require('../lib/file');
var _log_ = require('./log');

exports.clearSession = function(config){
    var clear = function(){
        harbors.log('开始清理session...');
        var dir_tmp = {};//缓存已检查的文件夹
        for(var p in config){
            if(config[p]['tmp_dir']){
                var pathDir = harbors.config[p]['tmp_dir'];
                harbors.log(pathDir);
                dir_tmp[pathDir] = true//记录查找过的文件夹
                pathDir = path.join(config[p]['tmp_dir'],'session');
                var files = __fs__.readDir(pathDir);
                files.map(function(a){
                    var path_tmp = path.join(pathDir,a);
                    var json = __fs__.readJson(path_tmp);
                    if(json&&json.time<new Date()-0) __fs__.unlink(path_tmp);
                });
            }
        }
        harbors.log('session清理完毕.');
    };
    clear();
    //定时检查session文件是否超时
    setTimeout(function(){
        clear();
    },3600000);
};

exports.createWorker = function(){
    harbors.log("启动子进程...");
    var worker = cluster.fork();
    worker.on('exit', function(code, signal) {
        //重启worker（此时进程id会增加1，以示和原错误关闭进程区别）
        !worker.suicide && (console.log('Separation of new sub process process...'),setTimeout(createWorker,2000));
    });
    //监听子进程事件
    worker.on('message',function(str,f){
        try{
            str = JSON.parse(str);
        }catch(err){
            console.log(err);
        }
        exports.message(str);
    });
};

exports.message = function(msg){
    switch(msg.type){
        case 'log':
            _log_.write(msg);
            break;
    }
};