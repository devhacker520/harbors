var url     = require('url')
    , fs      = require('fs')
    , path    = require("path")
    , http    = require("http")
    , net     = require("net")
    , sys     = require("sys")
    , fastcgi = require("./fastcgi");

var debug = 0 ? console : { log: function(){}, dir: function(){} };

var FCGI_RESPONDER = fastcgi.constants.role.FCGI_RESPONDER;
var FCGI_BEGIN     = fastcgi.constants.record.FCGI_BEGIN;
var FCGI_STDIN     = fastcgi.constants.record.FCGI_STDIN;
var FCGI_STDOUT    = fastcgi.constants.record.FCGI_STDOUT;
var FCGI_PARAMS    = fastcgi.constants.record.FCGI_PARAMS;
var FCGI_END       = fastcgi.constants.record.FCGI_END;

module.exports = function(request) {


    // Let's mix those options.
    var options = {
        fastcgiPort: request.vhost.fastcgi_port,
        fastcgiHost: request.vhost.fastcgi_host
    };
    var script_dir = request.vhost.dir;
    var script_file = request.path._url+request.vhost.module;

    var qs = url.parse(request.req.url).query ? url.parse(request.req.url).query : '';
    var params = makeHeaders(request.req.headers, [
        ["SCRIPT_FILENAME",script_dir + script_file],
        ["REMOTE_ADDR",request.req.connection.remoteAddress],
        ["QUERY_STRING", qs],
        ["REQUEST_METHOD", request.req.method],
        ["SCRIPT_NAME", script_file],
        ["PATH_INFO", script_file],
        ["DOCUMENT_URI", script_file],
        ["REQUEST_URI", request.req.url],
        ["DOCUMENT_ROOT", script_dir],
        ["PHP_SELF", script_file],
        ["GATEWAY_PROTOCOL", "CGI/1.1"],
        ["SERVER_SOFTWARE", "HARBORS " + harbors.version]
    ]);

    debug.log('Incoming Request: ' + request.method + ' ' + request.url);
    debug.dir(params);
    server(request, params, options);
};

var makeHeaders = function(headers, params) {
    if (headers.length <= 0) {
        return params;
    }

    for (var prop in headers) {
        var head = headers[prop];
        prop = prop.replace(/-/, '_').toUpperCase();
        if (prop.indexOf('CONTENT_') < 0) {
            // Quick hack for PHP, might be more or less headers.
            prop = 'HTTP_' + prop;
        }

        params[params.length] = [prop, head]
    }

    return params;
};

function server(request, params, options) {
    var connection = new net.Stream();
    connection.setNoDelay(true);

    var writer = null;
    var parser = null;

    var header = {
        "version": fastcgi.constants.version,
        "type": FCGI_BEGIN,
        "recordId": 0,
        "contentLength": 0,
        "paddingLength": 0
    };
    var begin = {
        "role": FCGI_RESPONDER,
        "flags": fastcgi.constants.keepalive.OFF
    };

    var collectedStdin = [], noMoreData = false;

    function endRequest() {
        if(writer) {
            header.type = FCGI_STDIN;
            header.contentLength = 0;
            header.paddingLength = 0;
            writer.writeHeader(header)
            connection.write(writer.tobuffer());
            connection.end();
        } else {
            noMoreData = true;
        }
    }

    function sendRequest (connection) {
        header.type = FCGI_BEGIN;
        header.contentLength = 8;
        writer.writeHeader(header);
        writer.writeBegin(begin);
        connection.write(writer.tobuffer());

        header.type = FCGI_PARAMS;
        header.contentLength = fastcgi.getParamLength(params);
        writer.writeHeader(header);
        writer.writeParams(params);
        connection.write(writer.tobuffer());


        header.type = FCGI_PARAMS;
        header.contentLength = 0;
        writer.writeHeader(header);
        connection.write(writer.tobuffer());

        // header.type = FCGI_STDOUT;
        // writer.writeHeader(header);
        // connection.write(writer.tobuffer());

        if((request.req.method != 'PUT' && request.req.method != 'POST')) {
            endRequest()
        } else {
            for(var j = 0; j < collectedStdin.length; ++j) {
                header.type = FCGI_STDIN;
                header.contentLength = collectedStdin[j].length;
                header.paddingLength = 0;
                writer.writeHeader(header);
                writer.writeBody(collectedStdin[j]);
                connection.write(writer.tobuffer());
            }
            collectedStdin = [];
            if(noMoreData) {
                endRequest();
            }
        }
    };

    request.req.on('data', function(chunk) {
        if(writer) {
            header.type = FCGI_STDIN;
            header.contentLength = chunk.length;
            header.paddingLength = 0;
            writer.writeHeader(header);
            writer.writeBody(chunk);
            connection.write(writer.tobuffer())
        } else {
            collectedStdin.push(chunk);
        }
    });

    request.req.on('end', endRequest);

    connection.ondata = function (buffer, start, end) {

        parser.execute(buffer, start, end);
    };

    connection.addListener("connect", function() {
        writer = new fastcgi.writer();
        parser = new fastcgi.parser();

        writer.encoding = 'binary';

        var body="", hadheaders = false;

        parser.onRecord = function(record) {
            if (record.header.type == FCGI_STDOUT && !hadheaders) {
                body = record.body;

                debug.log(body);

                var parts = body.split("\r\n\r\n");

                var headers = parts[0];
                var headerParts = headers.split("\r\n");

                body = parts[1];

                var responseStatus = 200;

                headers = [];
                try {
                    for(var i in headerParts) {
                        header = headerParts[i].split(': ');
                        if (header[0].indexOf('Status') >= 0) {
                            responseStatus = header[1].substr(0, 3);
                            continue;
                        }

                        headers.push([header[0], header[1]]);
                    }
                } catch (err) {
                    //console.log(err);
                }

                debug.log('  --> Request Response Status Code: "' + responseStatus + '"');

                if(responseStatus === "404") {
                    request.notFound();
                    parser.onRecord = function() {};
                    connection.end();
                    return;
                }

                //request.res.writeHead(responseStatus, headers);
                headers.map(function(a){
                    request.res.setHeader(a[0],a[1]);
                });
                request._statusCode = responseStatus;

                hadheaders = true;


            } else if(record.header.type == FCGI_STDOUT && hadheaders) {
                body += record.body;
            } else if(record.header.type == FCGI_END) {
                request.send(body)
            }
        };

        parser.onError = function(err) {
            //console.log(err);
        };

        sendRequest(connection);
    });

    connection.addListener("close", function() {
        connection.end();
    });

    connection.addListener("error", function(err) {
        sys.puts(sys.inspect(err.stack));
        connection.end();
    });

    connection.connect(options.fastcgiPort, options.fastcgiHost);
}